#!/usr/bin/env node

const crypto = require('crypto');
const fs = require('fs');
const path = require('path');

console.log('üîê Setting up environment variables for Med-Genie...\n');

// Generate a secure JWT secret
const jwtSecret = crypto.randomBytes(64).toString('base64');

// Create .env file content
const envContent = `# JWT Security Configuration
# ‚ö†Ô∏è CRITICAL: Never commit actual JWT_SECRET to version control
# This file was generated by setup-env.js

# Required: Strong JWT secret (minimum 64 characters)
JWT_SECRET=${jwtSecret}

# JWT Token Expiration Settings
JWT_EXPIRES_IN=15m                    # Access token lifetime (short for security)
REFRESH_TOKEN_EXPIRES_IN=7d           # Refresh token lifetime

# Security Headers
NEXT_PUBLIC_APP_URL=http://localhost:3000

# Database Configuration
DATABASE_URL="file:./dev.db"

# Rate Limiting
RATE_LIMIT_ENABLED=true
RATE_LIMIT_MAX_REQUESTS=100
RATE_LIMIT_WINDOW_MS=900000

# Environment
NODE_ENV=development
`;

// Write .env file
const envPath = path.join(__dirname, '..', '.env');
fs.writeFileSync(envPath, envContent);

console.log('‚úÖ Environment file created successfully!');
console.log(`üìÅ Location: ${envPath}`);
console.log(`üîë JWT Secret: ${jwtSecret.substring(0, 20)}...`);
console.log('\n‚ö†Ô∏è  IMPORTANT:');
console.log('1. Keep your .env file secure and never commit it to version control');
console.log('2. Use different secrets for development, staging, and production');
console.log('3. Consider using a secrets management service in production');
console.log('\nüöÄ You can now run: npm run dev');
